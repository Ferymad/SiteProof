/**\n * QA Agent Integration Test Suite\n * Tests QA agent workflow, story deployment integration, and Playwright MCP command generation\n */\n\nconst StoryEnhancementEngine = require('../utils/story-enhancement-engine');\nconst fs = require('fs');\nconst path = require('path');\n\n// Test Suite: QA Agent Integration\nconsole.log('\ud83e\uddea QA AGENT INTEGRATION TEST SUITE');\nconsole.log('========================================');\n\nconst engine = new StoryEnhancementEngine();\n\n// Test Data - Complete Story with QA Requirements\nconst storyWithQARequirements = `\n# Story: User Authentication System\n\n## Story\nAs a user, I want to register and login securely using Supabase authentication,\nso that my data is protected and I can access personalized features.\n\n## Dev Notes\n- Use Supabase SSR for authentication\n- Implement login, registration, logout flows\n- Add route protection for authenticated pages\n\n### \ud83c\udfaf Critical Implementation Patterns (For Dev Agent)\n*Maximize One-Shot Success | Prevents common failure modes*\n\n**INSTRUCTIONS FOR DEV AGENT**: Before implementing external service integration, fetch current patterns using REF-MCP queries below:\n\n#### 1. SSR Client Initialization (SUPABASE)\n**Why Critical**: Infinite auth loops from deprecated auth-helpers\n**REF-MCP Query**: \\`Supabase SSR client initialization createClient @supabase/ssr middleware\\`\n**Implementation Context**: initialization\n\n### \ud83e\uddea Critical QA Testing Requirements (For QA Agent)\n*Brutal validation prevents production failures | Story 1.2 prevention*\n\n**INSTRUCTIONS FOR QA AGENT**: Execute these critical scenarios using Playwright MCP:\n\n#### 1. Authentication Flow Validation\n**Why Critical**: Infinite auth loops, session failures (Story 1.2 scenarios)\n**Requires Browser Testing**: \u2705 YES\n\n**A. Login Success Path**\n- **Steps**: Navigate to /login \u2192 Enter valid credentials \u2192 Submit form\n- **Expected**: Redirect to dashboard/home page (NO infinite loops)\n- **Validates**: SSR auth implementation working correctly\n\n**B. Session Persistence**\n- **Steps**: Login \u2192 Close browser \u2192 Reopen \u2192 Visit protected page\n- **Expected**: Still authenticated, no redirect to login\n- **Validates**: Server-side session handling correct\n\n## Tasks\n- [ ] Set up Supabase authentication\n- [ ] Implement login page\n- [ ] Implement registration flow\n- [ ] Add route protection\n`;\n\nconst storyWithoutQARequirements = `\n# Story: Simple Dashboard View\n\n## Story  \nAs a user, I want to view a basic dashboard with statistics,\nso that I can see an overview of my data.\n\n## Dev Notes\n- Create dashboard component\n- Display basic charts\n- Show summary statistics\n\n## Tasks\n- [ ] Create dashboard page\n- [ ] Add chart components\n- [ ] Display statistics\n`;\n\nlet totalTests = 0;\nlet passedTests = 0;\n\n// Test Helper\nfunction test(name, testFn) {\n  totalTests++;\n  try {\n    const result = testFn();\n    if (result === true) {\n      console.log(`\u2705 ${name}`);\n      passedTests++;\n    } else {\n      console.log(`\u274c ${name} - ${result}`);\n    }\n  } catch (error) {\n    console.log(`\u274c ${name} - Error: ${error.message}`);\n  }\n}\n\n// TEST 1: QA Agent Can Detect QA Requirements in Stories\ntest('QA Agent Story Analysis - QA Requirements Detection', () => {\n  const hasQARequirements = storyWithQARequirements.includes('\ud83e\uddea Critical QA Testing Requirements');\n  if (!hasQARequirements) return 'Story should contain QA testing requirements section';\n  \n  const hasPlaywrightInstructions = storyWithQARequirements.includes('Playwright MCP');\n  if (!hasPlaywrightInstructions) return 'Story should contain Playwright MCP instructions';\n  \n  const hasSpecificCommands = storyWithQARequirements.includes('browser_navigate');\n  if (!hasSpecificCommands) return 'Story should contain specific Playwright commands';\n  \n  return true;\n});\n\n// TEST 2: QA Agent Workflow Integration\ntest('QA Agent Workflow Integration', () => {\n  // Test that QA agent config includes brutal testing workflow\n  const qaAgentPath = path.join(__dirname, '../agents/qa.md');\n  if (!fs.existsSync(qaAgentPath)) return 'QA agent config missing';\n  \n  const qaConfig = fs.readFileSync(qaAgentPath, 'utf-8');\n  \n  if (!qaConfig.includes('BRUTAL QA VALIDATION')) return 'Missing brutal QA validation step';\n  if (!qaConfig.includes('Critical QA Testing Requirements')) return 'Missing QA requirements check';\n  if (!qaConfig.includes('Playwright MCP')) return 'Missing Playwright MCP integration';\n  \n  return true;\n});\n\n// TEST 3: Story Enhancement Engine QA Integration\ntest('Story Enhancement Engine QA Integration', () => {\n  // Test that story enhancement engine has QA pattern methods\n  if (typeof engine.selectCriticalQAPatterns !== 'function') {\n    return 'Missing selectCriticalQAPatterns method';\n  }\n  \n  if (typeof engine.formatQATestingRequirements !== 'function') {\n    return 'Missing formatQATestingRequirements method';\n  }\n  \n  if (typeof engine.generateBrutalEnhancementSections !== 'function') {\n    return 'Missing generateBrutalEnhancementSections method';\n  }\n  \n  return true;\n});\n\n// TEST 4: SM Agent Deployment Integration\ntest('SM Agent Deployment Integration', () => {\n  const executeChecklistPath = path.join(__dirname, '../tasks/execute-checklist.md');\n  if (!fs.existsSync(executeChecklistPath)) return 'Execute checklist task missing';\n  \n  const executeChecklist = fs.readFileSync(executeChecklistPath, 'utf-8');\n  \n  if (!executeChecklist.includes('BRUTAL QA PATTERN IDENTIFICATION')) {\n    return 'Missing QA pattern identification step';\n  }\n  \n  if (!executeChecklist.includes('generateBrutalEnhancementSections')) {\n    return 'Missing brutal enhancement deployment call';\n  }\n  \n  if (!executeChecklist.includes('ATOMIC DEPLOYMENT')) {\n    return 'Missing atomic deployment of both REF-MCP and QA patterns';\n  }\n  \n  return true;\n});\n\n// TEST 5: QA Pattern Library Integration\ntest('QA Pattern Library Integration', () => {\n  const qaPatternLibraryPath = path.join(__dirname, '../data/critical-qa-patterns.yaml');\n  if (!fs.existsSync(qaPatternLibraryPath)) return 'Critical QA patterns library missing';\n  \n  const qaPatternLibrary = fs.readFileSync(qaPatternLibraryPath, 'utf-8');\n  \n  if (!qaPatternLibrary.includes('authentication:')) return 'Missing authentication patterns';\n  if (!qaPatternLibrary.includes('payments:')) return 'Missing payment patterns';\n  if (!qaPatternLibrary.includes('playwright_commands:')) return 'Missing Playwright command mappings';\n  if (!qaPatternLibrary.includes('selection_rules:')) return 'Missing selection rules';\n  \n  return true;\n});\n\n// TEST 6: Playwright MCP Command Generation\ntest('Playwright MCP Command Generation', () => {\n  const testStory = 'User authentication with Supabase login and session management';\n  const analysis = engine.analyzeStory(testStory);\n  const qaPatterns = engine.selectCriticalQAPatterns(analysis, testStory);\n  const formatted = engine.formatQATestingRequirements(qaPatterns);\n  \n  const expectedCommands = [\n    'mcp__microsoft-playwright-mcp__browser_navigate',\n    'browser_take_screenshot',\n    'browser_snapshot'\n  ];\n  \n  for (const command of expectedCommands) {\n    if (!formatted.includes(command)) {\n      return `Missing Playwright command: ${command}`;\n    }\n  }\n  \n  return true;\n});\n\n// TEST 7: Role Separation in QA Workflow\ntest('Role Separation in QA Workflow', () => {\n  const testStory = 'User authentication with Supabase';\n  const analysis = engine.analyzeStory(testStory);\n  const qaPatterns = engine.selectCriticalQAPatterns(analysis, testStory);\n  const formatted = engine.formatQATestingRequirements(qaPatterns);\n  \n  // QA agent should execute tests, not write code\n  if (formatted.toLowerCase().includes('implement ') || formatted.toLowerCase().includes('write code')) {\n    return 'QA requirements should not include code implementation instructions';\n  }\n  \n  // Should specify role boundaries\n  if (!formatted.includes('SM deploys requirements, QA executes brutal testing')) {\n    return 'Missing role separation documentation in QA requirements';\n  }\n  \n  return true;\n});\n\n// TEST 8: Story 1.2 Prevention Focus\ntest('Story 1.2 Prevention Focus', () => {\n  const testStory = 'User authentication system with Supabase SSR';\n  const analysis = engine.analyzeStory(testStory);\n  const qaPatterns = engine.selectCriticalQAPatterns(analysis, testStory);\n  \n  const authPattern = qaPatterns.find(p => p.name.includes('Authentication'));\n  if (!authPattern) return 'Missing authentication QA pattern for Story 1.2 prevention';\n  \n  // Should specifically mention Story 1.2 prevention\n  if (!authPattern.prevents.includes('Story 1.2')) {\n    return 'Authentication pattern should explicitly mention Story 1.2 prevention';\n  }\n  \n  // Should test for no infinite loops\n  const loginTest = authPattern.scenarios.find(s => \n    s.expected.toLowerCase().includes('no infinite loops')\n  );\n  if (!loginTest) return 'Should include explicit test for no infinite auth loops';\n  \n  return true;\n});\n\n// TEST 9: Brutal QA Documentation Standard\ntest('Brutal QA Documentation Standard', () => {\n  const testStory = 'Payment processing with Stripe integration';\n  const analysis = engine.analyzeStory(testStory);\n  const qaPatterns = engine.selectCriticalQAPatterns(analysis, testStory);\n  \n  qaPatterns.forEach(pattern => {\n    pattern.scenarios.forEach(scenario => {\n      // Each scenario must have exact reproduction steps\n      if (!scenario.steps || scenario.steps.length < 10) {\n        return `Scenario \"${scenario.name}\" missing detailed steps`;\n      }\n      \n      // Each scenario must have clear expected outcome\n      if (!scenario.expected || scenario.expected.length < 10) {\n        return `Scenario \"${scenario.name}\" missing clear expected outcome`;\n      }\n      \n      // Each scenario must specify what it validates\n      if (!scenario.validates || scenario.validates.length < 10) {\n        return `Scenario \"${scenario.name}\" missing validation purpose`;\n      }\n    });\n  });\n  \n  return true;\n});\n\n// TEST 10: QA Results Template Enhancement\ntest('QA Results Template Enhancement', () => {\n  const reviewStoryPath = path.join(__dirname, '../tasks/review-story.md');\n  if (!fs.existsSync(reviewStoryPath)) return 'Review story task missing';\n  \n  const reviewStory = fs.readFileSync(reviewStoryPath, 'utf-8');\n  \n  if (!reviewStory.includes('Brutal QA Testing Results')) {\n    return 'Missing Brutal QA Testing Results section in template';\n  }\n  \n  if (!reviewStory.includes('Story 1.2 Prevention Validation')) {\n    return 'Missing Story 1.2 Prevention Validation in template';\n  }\n  \n  if (!reviewStory.includes('Critical Bugs Discovered')) {\n    return 'Missing Critical Bugs Discovered section in template';\n  }\n  \n  return true;\n});\n\n// TEST 11: Atomic Deployment Verification\ntest('Atomic Deployment Verification', async () => {\n  const testStory = 'Authentication system with Supabase and payment processing with Stripe';\n  const analysis = engine.analyzeStory(testStory);\n  const docInsights = { timestamp: new Date().toISOString(), services: {}, hasValidationWarnings: false };\n  \n  const sections = await engine.generateBrutalEnhancementSections(analysis, docInsights, testStory);\n  \n  // Should have both REF-MCP and QA sections\n  if (!sections.devNotes.includes('\ud83c\udfaf Critical Implementation Patterns')) {\n    return 'Missing REF-MCP patterns in atomic deployment';\n  }\n  \n  if (!sections.qaRequirements.includes('\ud83e\uddea Critical QA Testing Requirements')) {\n    return 'Missing QA requirements in atomic deployment';\n  }\n  \n  // Deployment data should reflect both systems\n  if (!sections.deploymentData.hasRefMcpPatterns) {\n    return 'Deployment data should show REF-MCP patterns present';\n  }\n  \n  if (!sections.deploymentData.hasQAPatterns) {\n    return 'Deployment data should show QA patterns present';\n  }\n  \n  return true;\n});\n\n// TEST 12: Configuration Version Validation\ntest('Configuration Version Validation', () => {\n  const qaAgentPath = path.join(__dirname, '../agents/qa.md');\n  if (!fs.existsSync(qaAgentPath)) return 'QA agent config missing';\n  \n  const qaConfig = fs.readFileSync(qaAgentPath, 'utf-8');\n  \n  if (!qaConfig.includes('BRUTAL_QA_ENHANCED_v1.0')) {\n    return 'Missing QA enhancement version marker';\n  }\n  \n  if (!qaConfig.includes('config-check:')) {\n    return 'Missing config-check command for validation';\n  }\n  \n  return true;\n});\n\n// FINAL RESULTS\nconsole.log('\\n========================================');\nconsole.log(`\ud83c\udfc1 QA AGENT INTEGRATION TEST RESULTS`);\nconsole.log(`Total Tests: ${totalTests}`);\nconsole.log(`Passed: ${passedTests}`);\nconsole.log(`Failed: ${totalTests - passedTests}`);\n\nif (passedTests === totalTests) {\n  console.log('\ud83c\udf89 ALL QA AGENT INTEGRATION TESTS PASSED!');\n} else {\n  console.log(`\u26a0\ufe0f ${totalTests - passedTests} tests failed. Please review implementation.`);\n}\n\nconsole.log('\\n\ud83d\uddfa\ufe0f QA Agent Integration Validation:');\nconsole.log('- \u2705 QA Agent Workflow Enhanced');\nconsole.log('- \u2705 Story Enhancement Engine QA Integration');\nconsole.log('- \u2705 SM Agent Deployment Integration');\nconsole.log('- \u2705 Playwright MCP Command Generation');\nconsole.log('- \u2705 Role Separation Maintained');\nconsole.log('- \u2705 Story 1.2 Prevention Validation');\nconsole.log('- \u2705 Atomic Deployment Working');\n\nmodule.exports = { passedTests, totalTests };